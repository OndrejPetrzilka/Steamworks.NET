// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2018 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if UNITY_ANDROID || UNITY_IOS || UNITY_TIZEN || UNITY_TVOS || UNITY_WEBGL || UNITY_WSA || UNITY_PS4 || UNITY_WII || UNITY_XBOXONE || UNITY_SWITCH
#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System;
using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks
{
    [StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
    public struct SteamNetworkingQuickConnectionStatus
    {
        [StructLayout(LayoutKind.Explicit, Size = sizeof(UInt32) * 16)]
        public struct Reserved
        {
        }

        /// High level state of the connection
        public ESteamNetworkingConnectionState m_eState;

        /// Current ping (ms)
        public int m_nPing;

        /// Connection quality measured locally, 0...1.  (Percentage of packets delivered
        /// end-to-end in order).
        public float m_flConnectionQualityLocal;

        /// Packet delivery success rate as observed from remote host
        public float m_flConnectionQualityRemote;

        /// Current data rates from recent history.
        public float m_flOutPacketsPerSec;
        public float m_flOutBytesPerSec;
        public float m_flInPacketsPerSec;
        public float m_flInBytesPerSec;

        /// Estimate rate that we believe that we can send data to our peer.
        /// Note that this could be significantly higher than m_flOutBytesPerSec,
        /// meaning the capacity of the channel is higher than you are sending data.
        /// (That's OK!)
        public int m_nSendRateBytesPerSecond;

        /// Number of bytes pending to be sent.  This is data that you have recently
        /// requested to be sent but has not yet actually been put on the wire.  The
        /// reliable number ALSO includes data that was previously placed on the wire,
        /// but has now been scheduled for re-transmission.  Thus, it's possible to
        /// observe m_cbPendingReliable increasing between two checks, even if no
        /// calls were made to send reliable data between the checks.  Data that is
        /// awaiting the nagle delay will appear in these numbers.
        public int m_cbPendingUnreliable;
        public int m_cbPendingReliable;

        /// Number of bytes of reliable data that has been placed the wire, but
        /// for which we have not yet received an acknowledgment, and thus we may
        /// have to re-transmit.
        public int m_cbSentUnackedReliable;

        /// If you asked us to send a message right now, how long would that message
        /// sit in the queue before we actually started putting packets on the wire?
        /// (And assuming Nagle does not cause any packets to be delayed.)
        ///
        /// In general, data that is sent by the application is limited by the
        /// bandwidth of the channel.  If you send data faster than this, it must
        /// be queued and put on the wire at a metered rate.  Even sending a small amount
        /// of data (e.g. a few MTU, say ~3k) will require some of the data to be delayed
        /// a bit.
        ///
        /// In general, the estimated delay will be approximately equal to
        ///
        ///		( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond
        ///
        /// plus or minus one MTU.  It depends on how much time has elapsed since the last
        /// packet was put on the wire.  For example, the queue might have *just* been emptied,
        /// and the last packet placed on the wire, and we are exactly up against the send
        /// rate limit.  In that case we might need to wait for one packet's worth of time to
        /// elapse before we can send again.  On the other extreme, the queue might have data
        /// in it waiting for Nagle.  (This will always be less than one packet, because as soon
        /// as we have a complete packet we would send it.)  In that case, we might be ready
        /// to send data now, and this value will be 0.
        public SteamNetworkingMicroseconds m_usecQueueTime;

        /// Internal stuff, room to change API easily
        public UInt32 reserved;

    };
}
#endif //!DISABLESTEAMWORKS